<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>源码学习 | GodHandl</title><meta name="author" content="GodHandl"><meta name="copyright" content="GodHandl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java源码之Map系列HashMap源码：loadFactor 负载因子 1.8 hashMap源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public V put(K key, V value)">
<meta property="og:type" content="article">
<meta property="og:title" content="源码学习">
<meta property="og:url" content="http://example.com/2023/07/21/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="GodHandl">
<meta property="og:description" content="Java源码之Map系列HashMap源码：loadFactor 负载因子 1.8 hashMap源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public V put(K key, V value)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/20.jpg">
<meta property="article:published_time" content="2023-07-21T12:04:36.000Z">
<meta property="article:modified_time" content="2023-07-29T09:29:06.534Z">
<meta property="article:author" content="GodHandl">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/20.jpg"><link rel="shortcut icon" href="/img/favicon1.png"><link rel="canonical" href="http://example.com/2023/07/21/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '源码学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-29 17:29:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/20.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="GodHandl"><span class="site-name">GodHandl</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">源码学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-21T12:04:36.000Z" title="发表于 2023-07-21 20:04:36">2023-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-29T09:29:06.534Z" title="更新于 2023-07-29 17:29:06">2023-07-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="源码学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Java源码之Map系列"><a href="#Java源码之Map系列" class="headerlink" title="Java源码之Map系列"></a>Java源码之Map系列</h2><h3 id="HashMap源码："><a href="#HashMap源码：" class="headerlink" title="HashMap源码："></a>HashMap源码：</h3><p>loadFactor 负载因子</p>
<p>1.8 hashMap源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//Node数组的初始化与扩容</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//判断插入的位置是否为空，为空直接new一个对象</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//原位置中存在数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果与数组目标位置的第一个元素相等进行value替换</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果目标位置的元素是树的结点，将其放到树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不是树遍历循环到最后节点（尾插法）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//先插入数据再判断是否要转换成树的结构，放入时实际的链表长度为9；</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历过程中继续判断是否与新的key相同</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化和扩容操作</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容量大小左移一位，新出现的数组是原来的二倍，扩容后的遍历原数组数据原数组的目标的索引只可能在原位或（原位+原容量）所在的索引位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">//生成低位头节点和低位尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;<span class="comment">//生成高位头节点和高位尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//循环遍历生成俩个链表或红黑树</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap相关面试题："><a href="#HashMap相关面试题：" class="headerlink" title="HashMap相关面试题："></a>HashMap相关面试题：</h4><p><strong>5.为什么HashMap要使用红黑树而不是用AVL平衡树</strong></p>
<p>这就要说到AVL树和红黑树的特点了，这里简单说一下，红黑树的查询性能略微逊色于AVL树，因为相比AVL树红黑树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的AVL树最多多一次比较，但是，红黑树在插入和删除上优于AVL树，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多</p>
<p>总结：AVL查询性能好，增删性能差，红黑树查询和增删性能相对折中，实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择红黑树。</p>
<p>HashMap选择红黑树就是因为我们使用Map查询和增删该都会涉及到。</p>
<p>为什么不使用多叉树？多叉树和用于大数据存储，或者文件系统存储，不太适合HashMap这种小数据量存储结构。</p>
<ol start="6">
<li><strong>HashMap如何扩容的？</strong><br>HashMap的扩容因子是0.75，也就是说当数组中的已存储节点数（Node） &gt; 数组容量 ∗ 扩容因子时，就需要扩容，调整数组的大小为当前的 2 倍</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 扩容因子，元素个数达到容量的75%开始扩容</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
<p>扩容的方式是创建 2 倍容量的新的数组，然后把所有元素重新hash到新的数组中(数组长度变量，需要重新计算元素的存储位置)。</p>
<ol start="7">
<li><strong>HashMap是如何Put一个元素的？</strong><br> put执行流程如下：</li>
</ol>
<p>为key计算出hash值<br>根据key的hash值计算出存储位置(16 - 1) &amp; hash 等同于 hash % 16<br>取出该位置的值，如果为空，就把传入的key-value包装成Node，加入该位置<br>如果该位置已经有值了，就出现了hash碰撞了，该Node后面可能有一个链表，或者红黑树<br>判断该位置的元素的key和传入的key是否一样，如果一样就做值的覆盖操作<br>如果该位置的元素的key和传入的key不一样， 那就判断Node的类型是不是红黑树<br>如果是红黑树就走红黑树的添加流程<br>如果不是红黑树，就遍历链表，取出该位置的元素，使用next往后遍历 。如果遍历的过程中某个Key和传入的key一致了，就覆盖值，否则遍历到最后next为nul，就把传入的新元素存储到链表尾。<br>同时要判断链表的元素如果大于8了要进行红黑树的转换。</p>
<p>HashTable是HashMap的线程安全版本，也是比较老旧的一个map,HashTable方法是加了同步锁，线程安全，性能会受到影响。而HashMap没有加同步锁，线程不安全，但是性能更高。</p>
<p>Hashtable既不支持Null key也不支持Null value ， 而HashMap值可以为null，key支持一个key为nul。</p>
<p>HashMap简介<br>一、源码分析</p>
<ol>
<li>成员变量<br>1）面试题1：为了链表转红黑树的阈值是8？<br>2）面试题2：为什么负载因子默认是0.75？<br>3）面试题3：为什么HashMap的容量是2的n次幂？<br>4）面试题4：什么时候链表会转为红黑树（细节坑）？<br>5）面试题5：HashMap什么时候扩容？如何扩容？<br>2.构造方法<br>3.put()方法<br>1）面试题6：HashMap中的数组什么时候初始化？<br>2）面试题7：多线程环境下，put方法存在哪些问题？<br>3）面试题8：HashMap工作原理？<br>4）面试题9：当两个对象的hashcode相同会发生什么？<br>5）面试题10：HashMap的hash是如何实现的？</li>
<li>get()方法</li>
<li>resize()方法</li>
<li>remove()方法<br>常见其他面试题<br>1）面试题11：HashMap的几种遍历方式？<br>2）面试题12：HashMap、LinkedHashMap、TreeMap的区别和使用场景？<br>3）面试题13：HashMap和HashTable的区别？<br>HashMap简介<br>HashMap底层数据结构采用数组+ 链表 + 红黑树。数组是HashMap的主体，链表是为了解决Hash冲突的问题、红黑树是为了解决Hash冲突达到一定程度后影响查询效率问题。其通过散列映射来存储键值对数据，所以根据key的哈希值取模数组长度可以以O(1)的时间复杂度快速查询到键值对数据。另外，它是非线程安全的，并且因为散列hash的缘故，它是无序的。</li>
</ol>
<p>HashMap继承于AbstractMap，实现了Map、cloneable、Serializable接口；是线程不安全的；key、value允许为null，但只允许一个key值为null</p>
<p>一、源码分析</p>
<ol>
<li><p>成员变量<br>&#x2F;**</p>
<ul>
<li>初始容量默认为16，并且必须为2的n次幂.<br>*&#x2F;<br>static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>最大容量，MUST be a power of two &lt;&#x3D; 1&lt;&lt;30.<br>*&#x2F;<br>static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>默认负载因子<br>*&#x2F;<br>static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>链表转红黑树阈值<br>*&#x2F;<br>static final int TREEIFY_THRESHOLD &#x3D; 8;</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>红黑树转链表阈值.<br>*&#x2F;<br>static final int UNTREEIFY_THRESHOLD &#x3D; 6;</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>链表想转红黑树的前提必须是HashMap的table数组容量大于64，否者table两倍扩容<br><em>&#x2F;<br>static final int MIN_TREEIFY_CAPACITY &#x3D; 64;<br>&#x2F;</em>*</li>
<li>HashMap的主体：数组，容量可以为0，为了允许当前不需要的引导机制<br>*&#x2F;<br>transient Node&lt;K,V&gt;[] table;</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>将数据转成Set结构，供迭代器使用：keySet() and values().<br>*&#x2F;<br>transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>元素数量.<br>*&#x2F;<br>transient int size;</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>HashMap被修改的次数，在iterators中使用，其可以理解为一个乐观锁，用于快速失败(ConcurrentModificationException).<br>*&#x2F;<br>transient int modCount;</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>下一次要扩容的元素数量阈值，当元素数量达到threshold &#x3D;（capacity * load factor）时，进行2倍扩容。<br>*&#x2F;<br>int threshold;</li>
</ul>
<p> &#x2F;**</p>
<ul>
<li>负载因子<br>*&#x2F;<br>final float loadFactor;</li>
</ul>
<p> <strong>1）面试题1：为了链表转红黑树的阈值是8？</strong><br> 因为链表中的节点遵循泊松分布，并且链接表的节点数是8的概率接近千分之一，此时链表的查询性能已经很差了。在这种情况下，将链表转为红黑树可以挽回分布查询性能，而树节点所占空间是普通节点的二倍也不再是主要矛盾了。</p>
</li>
</ol>
<p><strong>2）面试题2：为什么负载因子默认是0.75？</strong><br>负载因子表示一个散列表的空间使用程度，HashMap的容量 &#x3D; capacity * loadFactory。loadFactory的默认值是0.75是为了在时间和空间上追求一种折中。</p>
<p>如果负载因子过高，虽然会扩大散列表的装填程度，使HashMap能容纳更多的元素；但是Hash碰撞的概率也会更高。<br>如果负载因子过低，虽然会降低hash碰撞的概率，提高数据检索的效率；但会造成空间上的浪费。<br><strong>3）面试题3：为什么HashMap的容量是2的n次幂？</strong><br>提高与运算的效率。与运算的效率高于取模运算，计算数组容量为2^n的下标时，与运算和取模运算的结果一样。并且与运算可以减少hash碰撞的概率。<br>进行数据迁移时，可以快速定位到索引位置。<br>顺带一提扰动函数：为了减少Hash碰撞的概率，尽量让不同的key对应不同的hash值。在hash()中的高16位与低16位异或就可以理解为是一种扰动函数。</p>
<p><strong>4）面试题4：什么时候链表会转为红黑树（细节坑）？</strong><br>这里说白了就是为了看你是否真的看过源码，因为HashMap中有个MIN_TREEIFY_CAPACITY变量，表示允许执行treeifyBin()操作HashMap的最小元素个数。<br>所以我们只答链表的长度达到8是不全对的，还要说出元素数量大于64。</p>
<p><strong>5）面试题5：HashMap什么时候扩容？如何扩容？</strong><br>当Map的元素个数size超过threshold（capacity * loadFactory）时，进行扩容。<br>扩容的时候：</p>
<p>会先创建一个原HashMap两倍大小的Node数组，然后将原Node数组的元素rehash到新的Node数组。<br>键值对的数组位置位置有可能是原数组下标位置、可有可能是原下标+原容量的位置。<br>也就是原本只取key-hash值的低四位，扩容后取第五位，然后与0X7FFFFF取模。取模后如果第五位是1，下标就在原下标+原容量的位置。<br>扩容时，JDK1.7采用头插法；JDK1.8之后采用尾插法。<br>2.构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设置初始容量和加载因子</span><br><span class="line"> */</span><br><span class="line">   public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">       if (initialCapacity &lt; 0)</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       this.loadFactor = loadFactor;</span><br><span class="line">       this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<pre><code>/**
 * 设置初始容量，并使用默认的加载因子
 */
public HashMap(int initialCapacity) &#123;
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
&#125;

/**
 * 空参构造函数，使用默认的加载因子0.75
 */
public HashMap() &#123;
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
&#125;

/**
 * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the
 * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with
 * default load factor (0.75) and an initial capacity sufficient to
 * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.
 *
 * @param   m the map whose mappings are to be placed in this map
 * @throws  NullPointerException if the specified map is null
 */
public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
&#125;
</code></pre>
<p>我们着重看一下最后一个构造函数：通过接收map对象进行初始化。</p>
<pre><code>final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;
    // 获取Map的size
    int s = m.size();
    if (s &gt; 0) &#123;
        // 数组还未初始化。
        if (table == null) &#123; // pre-size
            // Map的Capacity，为数组容量 / loadFactor , +1是为了向上取整，因为除法很难得到整数。
            float ft = ((float)s / loadFactor) + 1.0F;
            // 计算最大容量
            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                     (int)ft : MAXIMUM_CAPACITY);
            if (t &gt; threshold)
                // 容量转为2的n次幂
                threshold = tableSizeFor(t);
        &#125;
        // 大于扩容阈值则扩容
        else if (s &gt; threshold)
            resize();
        // 将m中的数据复制到HashMap中。
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        &#125;
    &#125;
&#125;
</code></pre>
<p>3.put()方法<br>HashMap的核心基本都体现在put方法，从put方法我们可以理解到HashMap的工作原理。</p>
<p>put方法流程图如下：</p>
<p>在聊put方法之前，我们先看看hash方法，HashMap是怎么计算key的哈希值的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="comment">// 使用到了上述提到的扰动函数，高十六位与低十六位异或</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>下面来看看put()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put()方法真正逻辑所在</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent true表示不更新现有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false，则表处于创建模式。HashMap中暂未使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// tab 哈希数组，p 该哈希桶的首节点，n hashMap的长度，i 计算出的数组下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果数组还没初始化，进行数组初始化。使用懒加载机制，table一开始是没有加载的，等put后才开始加载</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果根据key计算出的数组位置没有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    	<span class="comment">// 新建一个Node节点插入到相应数据位置。</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// key的hash值对应的数组下标位置不为空的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e 临时节点 ，k 当前节点的key</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//第一种，数组hash槽首节点的key与当前节点的相等，将当前节点赋值给临时节点e = p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// hash槽的数据结构为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 在红黑树中进行添加，如果该节点已经存在，则返回该节点（不为null），用与判断put操作是否成功，如果添加成功返回null</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果在链表尾部还没有找到当前key值，则在链表尾部新增节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 判断是否转红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果链表中有重复的key，e则为当前重复的节点，并结束链表的循环遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果key值以前已经存在，则对value进行覆盖，并返回value的旧值。</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 将红黑树的root节点放到链表队首，并将root Node存储在table数组中。</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这说明新增了一个Node节点，对Map的修改次数进行+1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// Map的元素容量+1，如果大于扩容阈值，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 模板方法，后置处理器</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1）面试题6：HashMap中的数组什么时候初始化？</strong><br>从HashMap的构造方法中我们可以看到，它只是指定一些成员变量（使用Map对象的构造方法除外）。<br>所以可以这样聊：</p>
<p>正常情况下，我们使用HashMap的构造方法之后只是指定一些成员变量、比如loadFactor、threshold。真正的初始化发生在给Map添加第一个元素时。<br>而使用map参数的构造方法时，初始化发生在构造方法中。但是本质上还是通过putVal()方法添加元素对数组进行初始化。<br><strong>2）面试题7：多线程环境下，put方法存在哪些问题？</strong><br>1、数据被覆盖</p>
<p>两个线程A&#x2F;B同时进行put操作，并且hash函数计算出要插入数组下标相同时，A线程刚计算完hash值还没来得及插入数据，CPU时间片耗尽被挂起。<br>线程B接着执行完了全部操作，然后线程A恢复，那么最终线程B插入的数据就被A覆盖了。<br>2、size偏小</p>
<p>++size操作是非原子性操作，存在线程安全问题。<br>加入两个线程A&#x2F;B同时进入++size操作，获取到原size的值一样，进行赋值操作时，它俩就等于是只给size+了1。<br><strong>3）面试题8：HashMap工作原理？</strong><br>HashMap基于数组+ 链表 + 红黑树的数据结构。数组是HashMap的主体，链表是为了解决Hash冲突的问题、红黑树是为了解决Hash冲突达到一定程度后影响查询效率问题。使用Node来存储键值对。<br>通过散列映射来存储键值对数据，所以根据key的哈希值取模数组长度可以以O(1)的时间复杂度快速查询到键值对数据。<br>接着聊一下负载因子的作用。<br>最后讲一讲put()方法流程。其中建议提到扰动函数、rehash等词汇。具体话术请读者参考put()方法流程图梳理。<br>get()、remove()方法捎带一提。<br><strong>4）面试题9：当两个对象的hashcode相同会发生什么？</strong><br>发生hash碰撞<br>因为hashCode相同，所以它们的bucket位置相同，‘碰撞’就发生了。<br>因为HashMap使用链表存储对象，这个Node对象会存储在链表中。当链表长度达到8时，链表将转为红黑树。<br><strong>5）面试题10：HashMap的hash是如何实现的？</strong><br>JDK1.8中，在hash()方法将hashCode的高16位与低16位做异或操作。<br>我们可以把它看做是一种扰动函数，hashCode的高16位和低16位都参与了数组下标的计算，减少了hash碰撞的概率。</p>
<ol start="4">
<li>get()方法<br>获取数据流程如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get()方法核心逻辑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// tab 数组，first 头结点，e 临时变量，n 长度,k key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">//头结点也就是数组下标的节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// //如果是头结点，则直接返回头结点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//不是头结点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否是红黑树结构</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 遍历红黑树</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//链表节点，遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找不到，表示不存在该节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>resize()方法<br>HashMap扩容逻辑：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 阶段一：计算newCap、newThr</span></span><br><span class="line">    <span class="comment">// 没插入数据之前的哈希数组oldTab</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// old数组的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// old扩容阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">// 新的数组容量和扩容阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// oldCap &gt; 0表示不是首次初始化，因为hashMap用的是懒加载</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 老数组容量大于最大容量（1 &lt;&lt; 30）时</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 扩容阈值为整数的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 然后就不扩容了</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两倍扩容，并且扩容后的长度要小于最大值、old容量要大于等于16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 扩容阈值变为原扩容阈值的2倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理情况：溢出越界</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">    newCap = oldThr;</span><br><span class="line"><span class="comment">// 新的HashMap首次初始化时，设置数组容量</span></span><br><span class="line"><span class="keyword">else</span> &#123;               </span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// 扩容阈值等于容量*加载因子</span></span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未指定HashMap容量初始化时，newThr没有赋值</span></span><br><span class="line"><span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 扩容阈值</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    <span class="comment">// 判断新数组容量是否大于最大值，扩容阈值是否大于最大值</span></span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容阈值赋值</span></span><br><span class="line">threshold = newThr;</span><br><span class="line"><span class="comment">// 表示忽略该警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">table = newTab;</span><br><span class="line"><span class="comment">// rehash操作，</span></span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        <span class="comment">// 临时变量</span></span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">// 当前哈希桶的位置值不为null，也就是数组下标处有值，因为有值表示可能会发生冲突</span></span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 把已经赋值之后的变量置位null，当然是为了便于回收，释放内存</span></span><br><span class="line">            oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 如果下标处的节点没有下一个元素，也就是普通节点</span></span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 把该变量的值存入newCap中，数组下标为e.hash &amp; (newCap - 1)</span></span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="comment">// 该节点为红黑树结构，也就是存在哈希冲突，该哈希桶中有多个元素</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 把此树进行转移到newCap中</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 此处表示为链表结构，同样把链表转移到newCap中；</span></span><br><span class="line">                <span class="comment">// 则将链表拆为高位链表和低位链表，分别放入新数组的旧数组的下标位置和 （旧数组下标 + 旧数组容量）下标位置；</span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="literal">null</span>;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回扩容后的hashMap</span></span><br><span class="line"><span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<ol start="6">
<li><p>remove()方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">//临时变量</span></span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">/**调用removeNode(hash(key), key, null, false, true)进行删除，第三个value为null，表示，把key的节点直接都删除了，不需要用到值，如果设为值，则还需要去进行查找操作**/</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**第一参数为哈希值，第二个为key，第三个value，第四个为是为true的话，则表示删除它key对应的value，不删除key,第四个如果为false，则表示删除后，不移动节点**/</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="comment">//tab 哈希数组，p 数组下标的节点，n 长度，index 当前数组下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">//哈希数组不为null，且长度大于0，然后获得到要删除key的节点所在是数组下标位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//nodee 存储要删除的节点，e 临时变量，k 当前节点的key，v 当前节点的value</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//如果数组下标的节点正好是要删除的节点，把值赋给临时变量node</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">//也就是要删除的节点，在链表或者红黑树上，先判断是否为红黑树的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//遍历红黑树，找到该节点并返回</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//表示为链表节点，一样的遍历找到该节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果进入了链表中的遍历，那么此处的p不再是数组下标的节点，而是要删除结点的上一个结点</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到要删除的节点后，判断!matchValue，我们正常的remove删除，!matchValue都为true</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//如果删除的节点是红黑树结构，则去红黑树中删除</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//删除的节点为数组下标节点，也就是头结点，直接让当前节点的next节点作为头节点（可能为 null）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="comment">// 删除的节点在链表中，把要删除的下一个结点设为上一个结点的下一个节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">//修改计数器</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">//长度减一</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">//模板方法，后置处理器</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">//返回删除的节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回null则表示没有该节点，删除失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 常见其他面试题<br> 1）面试题11：HashMap的几种遍历方式？<br> map.keySet() – 建议在只需要key值时使用。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="title function_">for</span> <span class="params">(String key : map.keySet()</span>) &#123;</span><br><span class="line">map.get(key);</span><br><span class="line">&#125;</span><br><span class="line">map.values() – 建议在需要使用value值时使用。</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="title function_">for</span> <span class="params">(String value:map.values()</span>)&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;value:&quot;</span>+value);</span><br><span class="line">&#125;</span><br><span class="line">map.entrySet() – 建议在需要同时使用k-v时使用。</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">    entry.getKey();</span><br><span class="line">    entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">map.entrySet().iterator() – 迭代器方式，需要对map的元素进行remove操作时。</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;String, Integer&gt; next = iterator.next();</span><br><span class="line"><span class="keyword">if</span> (next.getValue() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    iterator.remove();</span><br><span class="line">    System.out.println(<span class="string">&quot;To delete key &quot;</span> + next.getKey());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(String k : map.keySet()) &#123;</span><br><span class="line">System.out.println(k);</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>


<p>​    2）面试题12：HashMap、LinkedHashMap、TreeMap的区别和使用场景？<br>​    一般情况下HashMap当做Hash散列表使用。<br>​    在 Map 中进行插入、删除和定位元素操作时，使用HashMap。<br>​    TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）<br>​    在需要按自然顺序或自定义顺序遍历键的情况下使用TreeMap。<br>​    LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；<br>​    在需要输出的顺序和输入的顺序相同的情况下使用LinkedHashMap。<br>​    3）面试题13：HashMap和HashTable的区别？<br>​    HashMap允许key和value为null，Hashtable不允许。<br>​    HashTable在写入时会比较慢。HashMap速度比较快。<br>​    Hashtable是线程安全的，HashMap不是的。所以HashMap适用于单线程，HashTable多线程。<br>​    Hashtable的初始容量为11，扩容为原来的2n+1；HashMap的初始容量为16，扩容为2n。<br>​    HashMap提供了对key的Set进行遍历，因此HashMap是fast-fail的。HashTable提供了对key的Enumeration（列举）进行遍历，它不支持fast-fail。<br>​    Hashtable被认为是一个遗留的类，想要在迭代的时候修改Map，应该使用ConcurrentHashMap。</p>
<h3 id="集合源码学习—Iterator"><a href="#集合源码学习—Iterator" class="headerlink" title="集合源码学习—Iterator"></a>集合源码学习—Iterator</h3><p><img src="D:\JavaWeb\Mybatis\MyBatis的笔记\MyBatis\img\image-20221014132121738.png" alt="image-20221014132121738"></p>
<p>Enumeration 是一个很古老的迭代器，有两个方法：<br>hasMoreElements() &#x2F;&#x2F;是否还有元素<br>nextElement() &#x2F;&#x2F;返回下一个元素<br>Enumeration 的实现类会生成一系列子元素，比如 StringTokenizer；通过 Enumeration 的上述两个方法可以用来遍历它实现类的元素，比如这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringTokenizer : 切割, Breaks a string into tokens; new code should probably use &#123;@link String#split&#125;.</span></span><br><span class="line">   <span class="type">Enumeration</span> <span class="variable">enumeration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(<span class="string">&quot;A-B-C&quot;</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">   <span class="keyword">while</span> (enumeration.hasMoreElements())&#123;</span><br><span class="line">       System.out.println(enumeration.nextElement());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>所有 Collection 的子类都有 iterator() 方法来获得 Iterator，通过 Iterator 的标准操作方法，可以让我们不必关心具体集合的类型，从而避免向客户端暴露出集合的内部结构。</strong></p>
<h4 id="Java集合之迭代器"><a href="#Java集合之迭代器" class="headerlink" title="Java集合之迭代器"></a>Java集合之迭代器</h4><p><strong>在Java集合中较大一部分集合是存在快速失败机制的。</strong></p>
<p>　　<strong>快速失败机制产生的条件:当多个线程对Collection进行操作时，若其中某一个线程通过Iterator遍历集合时，该集合的内容被其他线程所改变，则会抛出ConcurrentModificationException异常。</strong></p>
<p>　　所以要保证在使用Iterator遍历集合的时候不出错误，就应该保证在遍历集合的过程中不会对集合产生结构上的修改。</p>
<p> <strong>使用Foreach时对集合的结构进行修改会出现异常:</strong></p>
<p>　　上面我们说了实现了Iterable接口的类就可以通过Foreach遍历，那是因为foreach要依赖于Iterable接口返回的Iterator对象，所以从本质上来讲，Foreach其实就是在使用迭代器，在使用foreach遍历时对集合的结构进行修改，和在使用Iterator遍历时对集合结构进行修改本质上是一样的。所以同样的也会抛出异常，执行快速失败机制。</p>
<p>　　foreach是JDK1.5新增加的一个循环结构，foreach的出现是为了简化我们遍历集合的行为。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="LinkedhashMap源码学习"><a href="#LinkedhashMap源码学习" class="headerlink" title="LinkedhashMap源码学习"></a>LinkedhashMap源码学习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<p>对于LinkedhashMap来说没有重写任何put方法，它重写了<code>newNode（）</code>方法使得再插入的时候先将节点放入一个双向链表中</p>
<p>其中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此链接哈希映射的迭代排序方法：访问顺序为true ，插入顺序为false </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写hashMap的生成新的节点的方法</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">newNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//红黑树节点</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">newTreeNode</span><span class="params">(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">        linkNodeLast(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将新节点插入链表尾部</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap和HashMap的异同点：</p>
<p>相同点<br>1.linkedHashMap虽然继承HashMap， 但实现了双线链表 ，有固定的顺序，与插入entry的顺序一样； 而HashMap存储的方式是无序的。<br>2.LinkedHashMap包含removeEldestEntry()方法，而HashMap则没有；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同点<br>key——value键值对：<br>1.Key和Value都允许空<br>2.Key重复会覆盖、Value允许重复</p>
<p>安全性：<br>非线程安全</p>
<p>继承关系：<br>都实现了Clonable ，serialiable（可序列化） ， map接口；</p>
<p>LinkedHashMap底层数据结构：<br>数组加链表<br>LinkedHashMap可以认为是HashMap+LinkedList，它可以使用HashMap操作数据结构，又使用LinkedList维护插入元素的先后顺序。</p>
<p>LinkedHashMap成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap维护了一个双向链表，header是链表头，不存储数据。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K, V&gt; header;</span><br><span class="line"><span class="comment">// accessOrder（有序性的标志），accessOrder=true（访问有序），默认为false（插入有序）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<p>Entry内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before：指向前一个entry元素。after：指向后一个entry元素</span></span><br><span class="line"></span><br><span class="line"> Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用的是父类HashMap的Entry构造</span></span><br></pre></td></tr></table></figure>

<p>next是用于维护HashMap指定table位置上连接的Entry的顺序的，before、After是用于维护Entry插入的先后顺序的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entry(<span class="type">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123; </span><br><span class="line">	<span class="built_in">super</span>(hash, key, value, next); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>LinkedHashMap并没有重写父类的put()方法，说明调用put方法时实际上调用的是父类的put方法。按照顺序将entry插入到头结点为header的双向链表中；</p>
<p>linkedHashMap的get（）方法：判断accessOlder的值 是需要按访问顺序还是遍历顺序来进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">     <span class="comment">//1.调用HashMap的getEntry方法得到e  </span></span><br><span class="line">     Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) getEntry(key); </span><br><span class="line">     <span class="keyword">if</span> (e == <span class="literal">null</span>)&#123;</span><br><span class="line">       	<span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//2.LinkedHashMap加入的操作 </span></span><br><span class="line">     e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">     <span class="keyword">return</span> e.value; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123; </span><br><span class="line">     LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">     <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">        lm.modCount++; </span><br><span class="line">     remove(); </span><br><span class="line">     <span class="comment">//因为是双向循环链表，所以在头节点之前插入的节点也就是链表的尾节点 			                     	</span></span><br><span class="line">     addBefore(lm.header); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> &#123; </span><br><span class="line">     after = existingEntry; </span><br><span class="line">     before = existingEntry.before; </span><br><span class="line">     before.after = <span class="built_in">this</span>; </span><br><span class="line">     after.before = <span class="built_in">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>LinkedHashMap的remove（）方法，是将双线链表的某一个节点移除，而不移除数组加链表上的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; 　　　　　　</span><br><span class="line">      <span class="comment">//this.before.after = this.after; 　　　　　　</span></span><br><span class="line">      <span class="comment">//this.after.before = this.before; 这样看可能会更好理解，this指的就是要删除的那个元素。 </span></span><br><span class="line">      before.after = after; </span><br><span class="line">      after.before = before; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap的containsValue方法：首先处理value为null的情况， 其次它不像HashMap一样遍历整个数组， 而是通过遍历双线链表header来查找value；</p>
<p>LinkedHashMap可以保存元素的插入顺序，顺序有两种方式一种是按照插入顺序排序，一种按照访问做排序。默认以插入顺序排序，性能比HashMap略低，线程也是不安全的。</p>
<p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果要按顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p>
<h2 id="Java集合之List系列："><a href="#Java集合之List系列：" class="headerlink" title="Java集合之List系列："></a>Java集合之List系列：</h2><h3 id="LinkedList学习"><a href="#LinkedList学习" class="headerlink" title="LinkedList学习"></a>LinkedList学习</h3><p><strong>linkedList中的迭代器：</strong></p>
<p>如果modCount与expectedModCount不相等就会抛出异常。</p>
<p>因为在你迭代之前，迭代器已经被通过list.itertor()创建出来了，如果在迭代的过程中，又对list进行了改变其容器大小的操作，那么Java就会给出异常。因为此时Iterator对象已经无法主动同步list做出的改变，Java会认为你做出这样的操作是线程不安全的，就会给出善意的提醒（抛出ConcurrentModificationException异常）。</p>
<p><strong>那么modCount与expectedModCount是怎么回事呢？</strong></p>
<p>modCount是在AbstractList中定义的一个变量，表示当前集合的增删次数，初始值为0，而LinkedList间接继承自AbstractList类，所以也有该属性，在该变量在对List进行添加（list.add()）或删除(list.remove())操作时进行加1处理，表示对集合进行了修改。<br>expectedModCount是在ListItr类中定义的一个变量，表示当前迭代器的增删次数，该类实现了ListIteratror<E>接口，初始值为modCount，在调用该迭代器内部的添加和删除方法时才变化，平时不变化。</p>
<h3 id="Vector学习"><a href="#Vector学习" class="headerlink" title="Vector学习"></a>Vector学习</h3><p>capacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。</p>
<p>同时Vector是线程安全的！</p>
<p><strong>ArrayList和Vector一样，同样的类似关系的类还有HashMap和HashTable，StringBuilder和StringBuffer，后者是前者线程安全版本的实现。</strong></p>
<p><strong>只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性</strong>。当执行synchronized修饰的方法前，系统会对该方法加一把锁，方法执行完成后释放锁，<strong>加锁和释放锁的这个过程，在系统中是有开销的，因此，</strong>在单线程的环境中，Vector效率要差很多。（多线程环境不允许用ArrayList，需要做处理）。</p>
<h3 id="Java集合系列-RandomAccess"><a href="#Java集合系列-RandomAccess" class="headerlink" title="Java集合系列-RandomAccess"></a>Java集合系列-RandomAccess</h3><p>Random是随机的意思，Access是访问的意思，合起来就是随机访问的意思。</p>
<p>RandomAccess接口是一个标记接口，用以标记实现的List集合具备快速随机访问的能力。</p>
<p>那么什么是随机访问的能力呢？其实很简单，随机访问就是随机的访问List中的任何一个元素。</p>
<p>所有的List实现都支持随机访问的，只是基于基本结构的不同，实现的速度不同罢了，这里的快速随机访问，那么就不是所有List集合都支持了。</p>
<ul>
<li>ArrayList基于数组实现，天然带下标，可以实现常量级的随机访问，复杂度为O(1)</li>
<li>LinkedList基于链表实现，随机访问需要依靠遍历实现，复杂度为O(n)</li>
</ul>
<p>当一个List拥有快速访问功能时，其遍历方法采用for循环最快速。而没有快速访问功能的List，遍历的时候采用Iterator迭代器最快速。</p>
<p>当我们不明确获取到的是Arraylist，还是LinkedList的时候，我们可以通过RandomAccess来判断其是否支持快速随机访问，若支持则采用for循环遍历，否则采用迭代器遍历</p>
<p>继承该接口的有</p>
<ul>
<li><p>ArrayList</p>
</li>
<li><p>Vector</p>
</li>
<li><p>CopyOnWriteArrayList</p>
</li>
<li><p>RandomAccessSubList</p>
</li>
<li><p>UnmodifiableArrayList</p>
</li>
</ul>
<h2 id="双端队列之Queue系列"><a href="#双端队列之Queue系列" class="headerlink" title="双端队列之Queue系列"></a>双端队列之Queue系列</h2><h3 id="ArrayDeque学习"><a href="#ArrayDeque学习" class="headerlink" title="ArrayDeque学习"></a>ArrayDeque学习</h3><p>arrayDeque是通过循环数组的方式实现的循环队列通过位运算提高效率容量始终是2的n次方幂</p>
<h3 id="PriorityQueue学习"><a href="#PriorityQueue学习" class="headerlink" title="PriorityQueue学习"></a>PriorityQueue学习</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">GodHandl</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/21/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">http://example.com/2023/07/21/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">GodHandl</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/20.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/07/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/" title="消息队列学习"><img class="cover" src="/img/24.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">消息队列学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">GodHandl</div><div class="author-info__description">我心无窍，天道酬勤</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/GodHandl" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1121968264@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%BA%90%E7%A0%81%E4%B9%8BMap%E7%B3%BB%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">Java源码之Map系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%BA%90%E7%A0%81%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">HashMap源码：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">HashMap相关面试题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E2%80%94Iterator"><span class="toc-number">1.2.</span> <span class="toc-text">集合源码学习—Iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">Java集合之迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedhashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.4.</span> <span class="toc-text">LinkedhashMap源码学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E4%B9%8BList%E7%B3%BB%E5%88%97%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">Java集合之List系列：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.1.</span> <span class="toc-text">LinkedList学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.2.</span> <span class="toc-text">Vector学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97-RandomAccess"><span class="toc-number">2.3.</span> <span class="toc-text">Java集合系列-RandomAccess</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E4%B9%8BQueue%E7%B3%BB%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">双端队列之Queue系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayDeque%E5%AD%A6%E4%B9%A0"><span class="toc-number">3.1.</span> <span class="toc-text">ArrayDeque学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PriorityQueue%E5%AD%A6%E4%B9%A0"><span class="toc-number">3.2.</span> <span class="toc-text">PriorityQueue学习</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/01/WebSocket%E6%95%B4%E5%90%88%E7%9B%B4%E6%92%AD/" title="WebSocket整合直播"><img src="/img/23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WebSocket整合直播"/></a><div class="content"><a class="title" href="/2023/08/01/WebSocket%E6%95%B4%E5%90%88%E7%9B%B4%E6%92%AD/" title="WebSocket整合直播">WebSocket整合直播</a><time datetime="2023-08-01T12:04:36.000Z" title="发表于 2023-08-01 20:04:36">2023-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/22/Java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" title="Java基础总结"><img src="/img/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础总结"/></a><div class="content"><a class="title" href="/2023/07/22/Java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" title="Java基础总结">Java基础总结</a><time datetime="2023-07-22T12:04:36.000Z" title="发表于 2023-07-22 20:04:36">2023-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/JVM%E4%B9%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/" title="JVM之方法的调用"><img src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM之方法的调用"/></a><div class="content"><a class="title" href="/2023/07/21/JVM%E4%B9%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/" title="JVM之方法的调用">JVM之方法的调用</a><time datetime="2023-07-21T12:04:36.000Z" title="发表于 2023-07-21 20:04:36">2023-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/JVM%E5%AD%A6%E4%B9%A0/" title="JVM学习"><img src="/img/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM学习"/></a><div class="content"><a class="title" href="/2023/07/21/JVM%E5%AD%A6%E4%B9%A0/" title="JVM学习">JVM学习</a><time datetime="2023-07-21T12:04:36.000Z" title="发表于 2023-07-21 20:04:36">2023-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/JVM%E9%9D%A2%E8%AF%95/" title="JVM面试"><img src="/img/15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM面试"/></a><div class="content"><a class="title" href="/2023/07/21/JVM%E9%9D%A2%E8%AF%95/" title="JVM面试">JVM面试</a><time datetime="2023-07-21T12:04:36.000Z" title="发表于 2023-07-21 20:04:36">2023-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By GodHandl</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index">豫ICP备2023002536号-1</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  function abcjsInit() {
    function abcjsFn() {
      for (let abcContainer of document.getElementsByClassName("abc-music-sheet")) {
        ABCJS.renderAbc(abcContainer, abcContainer.innerHTML, {responsive: 'resize'})
      }
    }
    
    typeof ABCJS === 'object' ? abcjsFn()
      : getScript('https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.min.js').then(abcjsFn)
  }

  window.pjax ? abcjsInit() : document.addEventListener('DOMContentLoaded', abcjsInit)
})()</script></div><div><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas></div><script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js"></script><script type="text/javascript" color="25,25,112" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>